# 자료구조

## 코드 리뷰 

1. 두 개 뽑아서 더하기

- 문제 설명

  💡Tip! 숫자를 적고 천천히 생각해보기 

```python
# 0 => 1,2,3,4          # 중복 => set()
# 1 => 2,3,4
# 2 => 3,4
# 3 => 4
# 4 => X

def solution(numbers):
  answer = []
  
  set_ = set()
  for i in range(len(numbers)):
    for j in range(i+1, len(numbers)):
      n1 = numbers[i]
      n2 = numbers[j]
      
      sum_ = n1 + n2
      
      set_.add(sum_)
      
   # 순서가 없는 set을 순서가 없는 list로 형변환
  list_=list(Set_)
  answer = sorted(list_)
  
  return answer
```

2. OX 퀴즈

- 문제 설명

💡TIP! 그리면서 해보기

```python
T = int(input())
O = "O"
X = "X"

for t in range(T):
  ox = input()
  count_o = 0
  sum_=0
  
  for answer in ox:
    if answer == O:
      count_o += 1 # 연속된 0의 개수 1 증가
      sum_=count_p + sum_
      
     if answer == X:
       count_o = 0 # 연속된 0의 개수를 초기화(0)
        
   print(sum_)
```

-----

## 알고리즘

### 1. 시간 복잡도 & 빅오 표기법

-  좋은 알고리즘이란 무엇일까? == 효율성? 성능? 
  - **input을 넣은 후 output이 나오는 시간이 짧은 알고리즘!**

#### 알고리즘의 소유 시간 측정하기 

- 개개인의 컴퓨팅 환경에 따라 **같은 알고리즘이라도 측정 시간이 다르다.**

  환경에 영햐을 받지 않는 **객곽적인 기준**이 필요

- 객관적인 측정을 위해 알고리즘 내부에서 **기본연산**이 **몇 번** 일어나는지 살펴본다.

  기본연산 : 단위 시간 1이 소요되는 시간 

  **기본연선의 총 횟수 == 알고리즘의 소요시간**

```python
def count(word, char):                  count("apple", "p")
total = 0                               >>> 2

for i in word:
  if i == char:
    total += 1
 
 return total 
```

- 기본연선의 횟수를 구하는 것은 환경에 영향을 받지 않는 객관적인 방법이지만,

  **입력의 개수**에 따라 시간이 달라진다는 문제가 있다.

  따라서 성능을 측정할 때는 **입력을 통일**시킨다.

- 가장 기본연산이 많이 일어나는 **최악의 입력 n개**가 들어온다고 가정한다.

```python
# 매 반복 마다 totla += 1번 실행
count("aaaaa", "a")
```

- 입력 n개에 따른 소요 시간을 수식으로 세울 수 있다.

##### 📌 시간 복잡도(Time Complexity)

> 단순하게 **알고리즘의 수행 시간**을 의미한다.

> 시간 복잡도가 높다 -> 느린 알고리즘

> 시간 복잡도가 낮다 -> 빠른 알고리즘 



### 2. 빅오(Big-O)표기법

- 입력 n이 **무한대**로 커진다고 가정하고 시간 복잡도를 간단하게 표시하는것

  **최고차향**만 남기고 계수와 상수 제거

- 매 입력에 따라 정확한 수식을 구하는 것은 불필요

  정확한 수치보다는 **증가율**

- 점근적 표기법에 의해 동일한 시간 복잡도가 나타남 

#### ✔️ 다양한 시간 복잡도 종류
![KakaoTalk_Photo_2022-07-26-11-16-32](https://user-images.githubusercontent.com/108647801/180971748-a5907b79-cfc3-45d6-888b-8fb615998f50.jpeg)

- `O(1)`: 단순 산술 계산(덧셈, 뺄셈, 곱셈, 나눗셈)
  - 단순 계산 -> a+b, 100*200
- `O(logN)`: 크기 N인 리스트를 반절씩 순회/ 탐색
  - 이진탐색(Binary Search), 분할정복(Divide & Conquer)
- `O(N)`: 크기 N인 리스트를 순회
  - 리스트 순회, 1중 for 문
- `O(NlogN)`: 크키 N인 리스트를 반절씩 탐색 *  순회
  - 높은 성능의 정렬(Merge/Quick/Heap Sort)
- `O(N^2)`: 크키 M,N인 2중 리스트를 순회
  - 2중 리스트 순회, 2중 for 문
- `O(N^3)`: 3중 리스트를 순회
  - 3중 리스트 순회, 3중 for 문
- `O(2^N)`: 크기 N 집합의 부분 집합
  - 크키가 N인 집합의 부분 집합
- `O(N!)`: 크키 N 리스트의 순열 
  - 크키가 N인 순열 

#### 첫 번째 방법 - 1부터 n까지 일일히 더하기

문제: 연속된 숫자 들의 합 구하기

제한 시간 : 1초

입력: 자연수 N이 입력된다.(1 <= N <= 1,00,000,000)

출력 : 1부터 N까지의 연속된 수를 모두 더한 값을 반환한다.

```python
def get_total(n):
  total = 0

  for i in range(1 , n+1):
    total += i
    
  return total

print(get_total(10))
>>> 55

print(get_total(100000000))
>>> 제한 시간 1초 초과
```

#### 두 번째 방법 - 가우스의 합 공식

```python
def get_total(n):
  reture (n * (n + 1))//2
  
print(get_total(10))
>>> 55

print(get_total(100000000))
>>> 5000000050000000
```

- 같은 Output을 만드는 알고리즘이라도 시간 복잡도에 따라 **성능**이 달라질 수 있고 서험에서 **정답 여부**가 갈리는 포인트가 된다.

#### ✔️ 내장 함수, 메서드의 시간 복답도도 확인할 필요가 있다.

- **for**문이 1분이라고 무조건 O(n)인 것은 아님

  for문 안에 O(n)의 내장 함수를 사용했다면, **이중 for문**과 다를 것이 없다.

----

## 리스트(List)

### 1. 배열 VS 연결리스트

- 배열(Array)

  > 여러 데이터들이 연속된 메모리 공간에 저장되어 있는 자료 구조

  - 인덱스를 통해 데이터에 빠르게 접근
  - 배열의 길이는 변경 불가능 -> 길이를 변경하고 싶다면 새로 생성
  - 데이터 타입은 고정 

- 연결 리스트(Linked List)

  > 데어터가 담긴 여러 노드들이 순차적으로 연결된 형태의 자료구조

  - 맨 처음 노드부터 순차적으로 탐색
  - 연결리스트의 길이 자유롭게 변경 가능 -> 삽입, 삭제가 편리
  - 다양한 데이터 타입 저장
  - 데이터가 메모리에 연속적으로 저장되지 않음 

### 2. 파이썬의 리스트

- `.append(원소)`

  리스트 맨 끝에 새로운 원소 **삽입**

- `.pop(인덱스)`

  특정 인덱스에 있는 원소를 **삭제 및 반환**

- `.count(원소)`

  리스트에서 해당 원소의 **개수**를 반환

- `.index(원소)`

  리스트에서 처음으로 원소가 등장하는 **인덱스** 반환

- `. Sort()`

  리스트 오름차순으로 **정렬 reverse=True** 옵션을 통해 내림차순으로 정렬 가능

- `.reverse()`

  리스트의 원소들의 순서를 거꾸로 **뒤집기**

- `Sorted(*iterable*)`

  오름차순으로 **정렬**된 새로운 리스트 반환 원본 리스트는 변화 없음

- `Reversed(*iterable*)`

  리스트의 순서를 거꾸로 **뒤집은** 새로운 객체 반환 원본 리스트는 변화 없음

----

### 3. 아스키(ASCII) 코드

> 컴퓨터는 숫자만 이해 가능 (2진법 - 비트, 바이트(1byte == 8bits))
>
> 그렇다면, 문자는 어떻게 저장될까? ▶️ **ASCII**

- `ord(문자)`
  - 문자 ▶️ 아스키코드로 변환하는 내장함수

- `chr(아스키코드)`
  - 아스키코드 ▶️ 문자로 변환하는 내장함수









##### 1

```python
#1
word = 'I play the piano'
print(word.split())

>>> ['I', 'play', 'the', 'piano']

#2
word = 'apple,banana,orange,grape'
print(word.split(','))

>>> ['apple', 'banana', 'orange', 'grape']

#3
word = 'This_is_snake_case'
print(word.split('_'))

>>> ['This', 'is', 'snake', 'case']
```



##### 2

```python
#1
word = ' Hello World'
print(word.strip())

>>> Hello Worlad

#2
word = 'aHello Worlda'
print(word.strip('a'))

>>> Hello World

#3
word = 'Hello World'
print(word.strip('Hd'))

>>> ello Worl
```



##### 3

```python
#1
word = 'apple'
print(word.find('p'))

>>> 1

#2
word = 'apple'
print(word.find('k'))

>>> -1
```



##### 4

```python
#1
word = 'apple'
print(word.index('p'))

>>> 1

#2
word = 'apple'
print(word.index('k'))

>>> ValueError
```



##### 5

```python
#1
word = 'banana'
print(word.count('a'))

>>> 3

#2
word = 'banana'
print(word.count('na'))

>>> 2

#3
word = 'banana'
print(word.count('ana'))

>>> 1
```



##### 6

```python
#1
word = 'happyhacking'
print(word.replace('happy, 'angry'))


>>> angryhacking
                   
#2
word = 'happyhacking'
print(word.replace('h','H'))
                   
>>> HappyHacking
                   
#3
word = 'happyhacking'
print(word.replace('happy',''))

>>>> hacking
```



##### 7

```python
#1
word = 'happyhacking'
print(' '.join(word))

>>> h a p p y h a c k i n g

#2
word = 'happyhacking'
print(','.join(word))

>>> h,a,p,p,y,h,a,c,k,i,n,g

#3
word = ['edu', 'hphk.kr']
print('@'.join(word))

>>> edu@hphk.kr
```
