# 깊이우선탐색(DFS)

## 1. 그래프 탐색 알고리즘

> 시작 정점에서 **간선을 타고 이동할 수 있는 모든 정점을 찾는** 알고리즘 

- 데이커 구조는 알고리즘의 재료가 되어 **문제를 해결** 하는데 사용된다

- 그래프 탐색 알고리즘에는 `깊이우선탐색`과 `너비우선탐색`이 있다. 

  - `깊이우선탐색(DFS)`

    그래프의 깊이를 우선으로 탐색하기 위해 **스택**의 개념을 활용

    ![depth-first-search-in-graph-data-structure](/Users/yuyeong/Desktop/TIL/알고리즘/알고리즘 22.08.10/알고리즘-05.assets/depth-first-search-in-graph-data-structure.webp)

  - `너비우선탐색(BFS)`

    그래프의 너비를 우선으로 탐색하기 위해 **큐**의 개념을 활용

![breadth-first-search-in-graph-data-structure](/Users/yuyeong/Desktop/TIL/알고리즘/알고리즘 22.08.10/알고리즘-05.assets/breadth-first-search-in-graph-data-structure.webp)

- 자료참고
  - [simplilearn](https://www.simplilearn.com/tutorials/data-structure-tutorial/graphs-in-data-structure)

---

## 2. 깊이우선탐색(Depth-First Search, DFS)

> 시작 정점으로부터 **갈 수 있는 하위 정점까지 가장 깊게 탐색**하고, 
>
> 더 이상 갈 곳이 없다면 마지막 갈림길로 돌아와서 다른 정점을 탐색하며 결국 모든 정점을 방문하는 순회 방법

- 깊이우선탐색을 미로 탈출로 생각하면 이해하기 쉽다
  - **어느 한 쪽 길로 가장 깊게 들어갔다가 막히면 다시 돌아와서 다른 길을 탐색**

-  🔻 깊이우선탐색(DFS)의 특징
  - `모든 정점을 방문`할 때 유리하다. 따라서 `경우의 수`, `순열과 조합`문제에서 많이 사용 한다. 
  - `너비우선탐색(BFS)`에 비해 코드 구현이 간단하다.
  - 단, 모든 정점을 방문할 필요가 없거나 최단 거리를 구하는 경우에는 `너비우선탐색(BFS)`이 유리하다.



---

## 3. DFS의 동작 과정

- DFS를 하기 전에, 일단 탐색을 진행할 그래프가 필요하다
  - 그래프는 `인접 행렬` 혹은 `인접리스트` 방식으로 표현할 수 있다

```python
# 인접 행렬
graph = [
  [0,1,1,0,0,0,0],
  [1,0,0,1,1,0,0],
  [1,0,0,0,1,1,0],
  [0,1,0,0,0,0,0],
  [0,1,1,0,0,0,1],
  [0,0,1,0,0,0,0],
  [0,0,0,0,1,0,0]
]


# 인접 리스트
graph =[
  [1,2],
  [0,3,4],
  [1],
  [1,2,6],
  [2],
  [4]
]
```

- **각 정점을 방문했는지 여부를 판별** 할 방문 체크 리스트다 필요
  - 사람과 달리 컴퓨터는 각 정점에 방문했는지 여부를 알 수 없다.
  - 따라서 visited 리스트를 따로 선언하여 각 정점을 방문했는지 체크한다.

```python
visited = [False] * n  # n은 정점의 개수 
```

| 정점 i     | 0     | 1     | 2     | 3     | 4     | 5     | 6     |
| ---------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| Visited[i] | False | False | False | False | False | False | False |

#### [DFS의 사이클]                                      

1. 현재 정점 방문처리                  

2. 인접한 모든 정점 확인

3. 방문하지 않은 인접 정점 이동 

   ![68747470733a2f2f692e6962622e636f2f6653347a4277622f696d6167652e706e67 (1)-0041165](/Users/yuyeong/Desktop/TIL/알고리즘/알고리즘 22.08.10/알고리즘-05.assets/68747470733a2f2f692e6962622e636f2f6653347a4277622f696d6167652e706e67 (1)-0041165-0098943.png)

   - 방문 정점 순서

     0 - 1 - 3 - 4 - 2 - 5 - 6

```python
visited[0] = True
graph[0]
>> [1,2]
visited[1] = True
graph [1]
>> [0,3,4]
```

---

## 4. DFS의 구현 방식

- 여기에서는 `인접 리스트`로 표현한 그래프를 기준으로 설명
- 반복문을 이용한 DFS
  - DFS는 직전에 방문한 정점으로 차례로 돌아가야 하므로, 후입선출(LIFO)구조의 `스택`을 사용

```python
visited =[False] * n  # 방문 처리 리스트 만들기

# def dfs(start):

visited[0] = True  # 시작 장점 방문 처리
# viistied[staryt]
stack = [0]  # 돌아갈 곳을 기록
# stack = [start]

while len(stack) != 0:  # 스택이 빌 때까지 (돌아갈 곳이 없을때까지) 반복
  cur = stack.pop() # 현재 방문 정점(후입선출)
  # cur = 0
  
  for adj in grahp[cur]: # 인접한 모든 정점에 대해
    if not visited[adj]: # 아직 방문하지 않았다면 
      visited[adj] = True # 방문처리
      stack.append(adj) # 스택에 넣어!
      
      
"""

for adj in [1,2]:
	if not visited[1]:
		visited[adj] = True
		stack.append(adj)
		
"""
```

---

##  5. DFS 문제 풀이

- [바이러스](https://www.acmicpc.net/problem/2606)

```python
n = int(input()) #정점 개수(컴퓨터)
m = int(input()) #간선 개수(네트워크)
graph =[[]for_in range(n+1)]   # 인덱스가 1부터 시작
visited = [False] * (n+1)
total = 0

# 인접 리스트 만들기
for _ in range(m):
  v1, v2 = map(int, input().split())
  grahp[v1].append(v2)
  grahp[v2].append(v1)

```

```python
visited = [False] * n

def dfs(start):
  stack = [start]
  visited[start] = True
  
  while stack:
    cur = stack.pop()
    
    for adj in graph[cur]:
      if not visited[adj]:
        visited[adj] = True
        stack.append(adj)
dfs(1)  # 1번 정점에서 시작 
```

